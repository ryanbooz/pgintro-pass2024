--creating databases

--getting a list of databases
SELECT
	pd.oid,
	pd.datname,
	pd.datistemplate
FROM
	pg_database AS pd;
	

--creating a database
CREATE DATABASE ourfirstdb;

DROP database ourfirstdb;


--creating a role
CREATE ROLE newowner;

CREATE TABLESPACE newtablespace '/bu'




--controlling creation
CREATE DATABASE controlled OWNER newowner 
	TABLESPACE newtablespace TEMPLATE template0;


--changing a database
ALTER DATABASE ourfirstdb 
OWNER TO newowner;


--more changes
ALTER DATABASE ourfirstdb 
SET datestyle = 'Postgres, DMY';


--resetting to default
ALTER DATABASE ourfirstdb RESET ALL;


--removing database
DROP DATABASE IF EXISTS ourfirstdb;



-- should you do this?
DROP DATABASE IF EXISTS ourfirstdb WITH (FORCE);



--restores and backups
--run this before going to VSCode
CREATE DATABASE backmeup;
CREATE TABLE public.watchme(id int);

--over to vscode

DROP DATABASE IF EXISTS backmeup;
CREATE DATABASE backmeup;






--database objects
--create a test database
CREATE DATABASE ObjectDemo;

--switch connection to ObjectDemo
--start with a schema
CREATE SCHEMA radio;

--first table
CREATE TABLE radio.radiobrand 
    (radiobrandid int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    radiobranddesc varchar(50) NOT NULL);
   

--drop table radio.radios;
--another table, with named constraint
CREATE TABLE IF NOT EXISTS radio.radios
	(radio_id int CONSTRAINT pkradios 
                  PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
	radio_name varchar(100) NOT NULL,
	radiobrandid int NOT NULL,
	picture BYTEA NULL,
	connectortype_id int NOT NULL,
	digitalmode_id int NULL
);


--adding a foreign key
ALTER TABLE radio.radios
ADD FOREIGN KEY (radiobrandid) 
            REFERENCES radio.radiobrand;
           



	

--Another way to create FK
CREATE TABLE IF NOT EXISTS radio.radios
(
   radio_id int CONSTRAINT pkradios PRIMARY KEY 
                             GENERATED ALWAYS AS IDENTITY,
   radio_name varchar(100) NOT NULL,
   manufacturer_id int NOT NULL,
   picture BYTEA NULL,
   connectortype_id int NOT NULL,
   digitalmode_id int NULL,
   CONSTRAINT radios_fk_manufacturer3 FOREIGN KEY 
                                     (manufacturer_id) 
   REFERENCES radio.manufacturers ON
DELETE
	RESTRICT
);


--check constraints
CREATE TABLE IF NOT EXISTS radio.bands
(
 band_id int CONSTRAINT pkbands PRIMARY KEY 
                         GENERATED ALWAYS AS IDENTITY,
 band_name varchar(100) NOT NULL,
 frequency_start_khz numeric(9,2) NOT null 
     CONSTRAINT minfrequency check (frequency_start_khz >135.7),
 frequency_end_khz numeric(9,2) NOT NULL,
 country_id int NOT NULL
);

ALTER TABLE radio.bands
ADD CONSTRAINT startlessthanend 
     CHECK (frequency_start_khz < frequency_end_khz);
    
    
--exclusion constraints
CREATE EXTENSION btree_gist;
CREATE SCHEMA logging;

CREATE TABLE IF NOT EXISTS logging.logs
(log_id int CONSTRAINT pklogs PRIMARY KEY 
                          GENERATED ALWAYS AS IDENTITY,
log_date timestamptz  NOT NULL,
log_callsign text,
log_location point NOT NULL);



ALTER TABLE logging.logs
ADD CONSTRAINT uniquecontact EXCLUDE
	USING gist (log_date WITH =,
	log_callsign WITH =,
log_location WITH ~=);


INSERT INTO logging.logs
(log_date,log_callsign,log_location)
VALUES
('12/21/2022','KC1KCE','35.952, -96.152'),
('12/21/2022','KC1KCE','35.957, -96.127');


INSERT INTO logging.logs
(log_date,log_callsign,log_location)
VALUES
('12/21/2022','KC1KCE','35.952, -96.152');


--indexes
--don't run this
CREATE INDEX radios_radioname ON radio.radios(radio_name);


--the right way
CREATE INDEX IF NOT EXISTS radios_radioname ON radio.radios USING BTREE(radio_name);


--bad idea
--run three or four times
CREATE INDEX ON radio.radios (digitalmode_id);


--example of a hash
CREATE INDEX bands_band_name ON radio.bands USING HASH(band_name);

--example of a filtered hash
CREATE INDEX logs_log_date ON logging.logs USING HASH(log_date)
WHERE log_date > '1/1/2020';




--monitoring
SHOW logging_collector;


--cumulative statistics system
SELECT
	psa.datname,
	psa.usename,
	psa.query,
	psa.xact_start,
	psa.query_start
FROM
	pg_stat_activity AS psa;



SELECT
	psd.tup_returned,
	psd.tup_inserted,
	psd.tup_updated,
	psd.tup_deleted
FROM
	pg_stat_database AS psd
WHERE
	psd.datname = 'bluebox';




SELECT
	psut.relname,
	psut.seq_scan,
	psut.last_seq_scan
FROM
	pg_stat_user_tables AS psut
WHERE
	psut.schemaname = 'public'
	AND psut.seq_scan > 0
ORDER BY
	psut.last_seq_scan DESC;
	

SELECT
	psui.schemaname,
	psui.relname,
	psui.indexrelname,
	psui.idx_scan,
	psui.idx_tup_read,
	psui.last_idx_scan
FROM
	pg_stat_user_indexes AS psui
WHERE
	psui.idx_scan > 0
	AND psui.idx_tup_read > 0;



SELECT
	psut.relname,
	psut.heap_blks_read,
	psut.heap_blks_hit
FROM
	pg_statio_user_tables AS psut
WHERE
	psut.schemaname = 'staging';



--queries



