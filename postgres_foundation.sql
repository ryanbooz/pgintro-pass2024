/*
 * Let's create the first table. Things to note:
 * 
 * We create an identity with the SQL standard. Historically that's been done
 * with a SERIAL column, which is depricated. Under the covers you'll see the
 * same thing (a sequence attached to the column)
 * 
 * We've also made our text column TEXT. While CHAR/VARCHAR is supported, they
 * provide no tangible benefit over a regular constraint on the TEXT column
 * 
 * Finally, the TEXT fields in Postgres are UTF-8 by default and there is no
 * secondary column type for international text characters (🐘😎)
 */
CREATE TABLE sensor ( 
	sensor_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	sensor_name TEXT NOT NULL,
	sensor_location TEXT NOT NULL,
	created timestamptz DEFAULT now()
);


/*
 * Insert some values to this new table
 */
INSERT INTO sensor (sensor_name, sensor_location) VALUES 
	('sensor1','basement'),
	('sensor2','roof'),
	('sensor5','server room'),
	('sensor100','entrance');

/*
 * And now select the data. Notice the auto generated IDs.
 */
SELECT * FROM sensor;


/*
 * Delete a row and insert it again
 */
DELETE FROM sensor WHERE sensor_name='sensor100';
INSERT INTO sensor (sensor_name, sensor_location) VALUES ('sensor100','garage');

/*
 * What's happened to the identity column?
 */
SELECT * FROM sensor;

/*
 * And what's the current high value of the sequence?
 */
SELECT currval(pg_get_serial_sequence('sensor','sensor_id'));


/*
 * Update the ID. 😱
 */
UPDATE sensor SET sensor_id=4 WHERE sensor_name='sensor100';

/*
 * The current value doesn't change because it's independent from
 * the sequence
 */
SELECT currval(pg_get_serial_sequence('sensor','sensor_id'));

/*
 * We can reset the value so that it's ready to stay in order
 */
SELECT setval(pg_get_serial_sequence('sensor','sensor_id'),COALESCE(max(sensor_id),1)) FROM sensor;


/*
 * Now let's create a simple table to hold time-series readings for our sensors. Currently
 * there are no primary keys, something we could determine later.
 */
CREATE TABLE Sensor_Reading (
	reading_date timestamptz NOT NULL,
	sensor_id int NOT NULL REFERENCES sensor (sensor_id) ON DELETE CASCADE,
	cpu float4,
	temperature float4	
);

/*
 * Let's insert some data. We'll talk about some of this in more depth later
 */
INSERT INTO sensor_reading
    -- The ROUND function requires a numeric value
	SELECT i, sid, round((random()*100)::numeric,2), round((random()/4*100)::NUMERIC,1)
	FROM 
		 -- This is the same as doing a CROSS JOIN between two tables, this time they
		 -- are just generated tables of data.
		 generate_series(1,4) AS g1(sid), 
		 generate_series('2024-11-05','2024-11-06','10 second'::interval) AS g2(i);


/*
 * Let's see if the data is there and we can select it?
 */
SELECT avg(cpu) FROM sensor_reading WHERE sensor_id = 2;

/*
 * How does the server get the data and how much work (buffers)
 * does it need to retrieve to get the result?
 */
EXPLAIN (ANALYZE, buffers)
SELECT avg(cpu) FROM sensor_reading WHERE sensor_id = 2;

/*
 * We can probably make that better, right?
 */
CREATE INDEX idx_sensor_id ON sensor_reading (sensor_id);

/*
 * We can also do easy date math
 */
SELECT sensor_id, avg(temperature) FROM sensor_reading
	WHERE sensor_id IN (SELECT sensor_id FROM sensor WHERE sensor_location = 'basement')
	AND reading_date >  '2023-11-01'::timestamptz - INTERVAL '12 hours'
GROUP BY 1;
	

/*
 * I want to have some dynamic SQL that I can change a variable
 * and run a few times.
 */
DECLARE sloc TEXT = 'basement';
BEGIN
	RETURN select sensor_id, avg(temperature) FROM sensor_reading
	WHERE sensor_id IN (SELECT sensor_id FROM sensor WHERE "sensor_location" = sloc)
		AND reading_date >  '2022-10-02'::timestamptz - INTERVAL '12 hours'
	GROUP BY 1;
END

/*
 * Ah! let's do that in an anonymous code block!!
 */
DO
$$
DECLARE sloc TEXT = 'basement';
BEGIN
	RETURN select sensor_id, avg(temperature) FROM sensor_reading
	WHERE sensor_id IN (SELECT sensor_id FROM sensor WHERE "sensor_location" = sloc)
		AND reading_date >  '2022-10-02'::timestamptz - INTERVAL '12 hours'
	GROUP BY 1;
END
$$;

/*
 * Alright... that got way more complicated than I wanted.
 */
DO
$$
DECLARE sloc TEXT = 'basement';
sqlstr TEXT;
BEGIN
	CREATE TEMPORARY TABLE t1(sensor_id int, avg_temp float4);

	sqlstr = format($_$insert INTO t1 select sensor_id, avg(temperature) FROM sensor_reading
			WHERE sensor_id IN (SELECT sensor_id FROM sensor WHERE "sensor_location" = %L)
			AND reading_date >  '2023-11-01'::timestamptz - INTERVAL '12 hours'
			GROUP BY 1$_$,sloc);
		
	RAISE NOTICE '%', sqlstr;

	EXECUTE sqlstr;
END
$$;

SELECT * FROM t1;

DROP TABLE t1;


/*
 * Assuming we'll do this a bunch, a function is the best long-term bet.
 */
CREATE FUNCTION avg_temp_for_loc(sloc text) RETURNS
TABLE(sensor_id int, avg_temp float4)
LANGUAGE SQL
AS $_$
	select sensor_id, avg(temperature) FROM sensor_reading
			WHERE sensor_id IN (SELECT sensor_id FROM sensor WHERE "sensor_location" = $1)
			AND reading_date >  '2022-10-02'::timestamptz - INTERVAL '12 hours'
			GROUP BY 1;
$_$


SELECT * FROM avg_temp_for_loc('basement');

/*
 * One last thing to discuss quickly - cases in PostgreSQL
 */
CREATE TABLE TestCase(c1 int);
INSERT INTO testcase VALUES (1);
SELECT * FROM TestcasE;
SELECT * FROM "TeStCaSe";

DROP TABLE testcase;

CREATE TABLE "TestCase"(c1 int);
INSERT INTO testcase VALUES (1);

DROP TABLE "TestCase";


/*
 * Demo Cleanup if you want to
 */
--DROP TABLE sensor_reading;
--DROP TABLE sensor CASCADE;